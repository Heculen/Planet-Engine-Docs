.. _doc_gdscript:

GDScript 参考
==================

GDScript 是一种高级的、 `面向对象 <https://en.wikipedia.org/wiki/Object-oriented_programming>`_ 、 `命令式 <https://en.wikipedia.org/wiki/Imperative_programming>`_ ，以及 `渐进类型 <https://en.wikipedia.org/wiki/Gradual_typing>`_ 为 Planet Engine 构建的编程语言。它使用基于缩进的语法，类似于 `Python <https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_ 等语言。
其目标是针对 Planet Engine 进行优化并与其紧密集成，从而为内容创建和集成提供极大的灵活性。

GDScript 完全独立于 Python，并不基于它。

GDscript 示例
""""""""""""""""

考虑到部分开发者了解过编程语法，学起GDScript来会较为上手，这里给出一个简单的 GDScript 示例供参考学习。

::

    # “#”号后的都是注释
    # 一个文件就是一个类！

    # （可选）在编辑器对话框中显示的图标：
    @icon("res://path/to/optional/icon.svg")

    # （可选）类定义：
    class_name MyClass

    # 继承:
    extends BaseClass


    # 成员变量
    var a = 5
    var s = "Hello"
    var arr = [1, 2, 3]
    var dict = {"key": "value", 2: 3}
    var other_dict = {key = "value", other_key = 2}
    var typed_var: int
    var inferred_type := "String"

    # 常量
    const ANSWER = 42
    const THE_NAME = "Charly"

    # 枚举
    enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
    enum Named {THING_1, THING_2, ANOTHER_THING = -1}

    # 内部定义的向量类型
    var v2 = Vector2(1, 2)
    var v3 = Vector3(1, 2, 3)


    # 函数
    func some_function(param1, param2, param3):
        const local_const = 5

        if param1 < local_const:
            print(param1)
        elif param2 > 5:
            print(param2)
        else:
            print("Fail!")

        for i in range(20):
            print(i)

        while param2 != 0:
            param2 -= 1

        match param3:
            3:
                print("param3 is 3!")
            _:
                print("param3 is not 3!")

        var local_var = param1 + 3
        return local_var


    # 函数会覆盖基类/超类上同名的函数。
    # 如果您仍然想调用它们，请使用“super”：
    func something(p1, p2):
        super(p1, p2)


    # 也可以调用超类中的另一个函数：
    func other_something(p1, p2):
        super.something(p1, p2)


    # 内部类
    class Something:
        var a = 10


    # 构造函数
    func _init():
        print("Constructed!")
        var lv = Something.new()
        print(lv.a)

如果您以前有使用静态类型语言（例如 C、C++ 或 C#）的经验，但之前从未使用过动态类型语言，建议您阅读 `本教程 <http:/www.bilibili.com>`_ 。

标识符
-----------

任何限制为字母字符（``a`` 到 ``z`` 和 ``A`` 到 ``Z``）、数字（``0`` 到 ``9``）和 ``_`` 可以作为标识符。此外，标识符不得以数字开头。标识符区分大小写（ ``foo`` 与 ``FOO`` 不同）。

标识符还可能包含 `UAX#31 <https://www.unicode.org/reports/tr31/>`__ 的大多数 Unicode 字符部分。这允许您使用以英语以外的语言编写的标识符名称。标识符中不允许使用被视为与 ASCII 字符和表情符号“混淆”的 Unicode 字符。

关键字
--------

以下是该语言支持的关键字列表。由于关键字是保留字（标记），因此它们不能用
作标识符。以下各节中列出的运算符（如 ``in`` 、 ``not`` 、 ``and`` 或 ``or`` ）和内置类型的名称也被保留。

关键字在 `GDScript tokenizer <https://github.com/godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ 中定义，以防您想深入了解。

+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
|  Keyword   | 描述                                                                                                                                              |
+============+===================================================================================================================================================+
| if         | 见 `if/else/elif`_.                                                                                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| elif       | 见 `if/else/elif`_.                                                                                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| else       | 见 `if/else/elif`_.                                                                                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| for        | 见 for_.                                                                                                                                          |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| while      | 见 while_.                                                                                                                                        |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| match      | 见 match_.                                                                                                                                        |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| when       | 由 ``match`` 语句中的 `模式保护` 使用                                                                                                             |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| break      | 用于跳出 ``for`` 与 ``while`` 循环                                                                                                                |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| continue   | 立即跳到 ``for`` 或 ``while`` 循环的下一次迭代                                                                                                    |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| pass       | 在语法上需要语句但不希望执行代码的情况下使用,例如在空函数中,常用于站位                                                                            |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| return     | 从函数返回一个值                                                                                                                                  |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| class      | 定义一个内部类。请参阅 内部类                                                                                                                     |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| class_name | 将脚本定义为具有指定名称的全局可访问类。请参阅 注册命名类_                                                                                        |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| extends    | 定义用当前类扩展哪个类                                                                                                                            |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| is         | 测试变量是否扩展给定的类，或者是否属于给定的内置类型                                                                                              |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| in         | 通常情况下用来检测字符串、列表、范围、字典、节点中是否存在某个值，而和 ``for`` 关键字连用时，则用于遍历字符串、列表、范围、字典、节点中的内容     |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| as         | 尝试将值转换为给定类型的值                                                                                                                        |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| self       | 引用当前类实例                                                                                                                                    |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| super      | 解析父类作用域内的方法，参见 继承                                                                                                                 |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| signal     | 定义一个信号                                                                                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| func       | 定义一个函数                                                                                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| static     | 将一个函数声明为静态函数，或将一个成员变量声明为静态成员变量                                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| const      | Defines a constant.                                                                                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| enum       | Defines an enum.                                                                                                                                  |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| var        | Defines a variable.                                                                                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| breakpoint | Editor helper for debugger breakpoints. Unlike breakpoints created by clicking in the gutter, ``breakpoint`` is stored in the script itself.      |
|            | This makes it persistent across different machines when using version control.                                                                    |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| preload    | Preloads a class or variable. See `Classes as resources`_.                                                                                        |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| await      | Waits for a signal or a coroutine to finish. See `Awaiting signals or coroutines`_.                                                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| yield      | Previously used for coroutines. Kept as keyword for transition.                                                                                   |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| assert     | Asserts a condition, logs error on failure. Ignored in non-debug builds. See `Assert keyword`_.                                                   |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| void       | Used to represent that a function does not return any value.                                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| PI         | PI constant.                                                                                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| TAU        | TAU constant.                                                                                                                                     |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| INF        | Infinity constant. Used for comparisons and as result of calculations.                                                                            |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+
| NAN        | NAN (not a number) constant. Used as impossible result from calculations.                                                                         |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------+

运算符
---------

下列为 GDScript 所支持的运算符及其运算优先级。所有二进制运算符均为 `左结合运算符 <https://en.wikipedia.org/wiki/Operator_associativity>`_ ，其中就包括 ``**`` ，即 ``2 ** 2 ** 3`` 等价于 ``(2 ** 2) ** 3`` 。为避免运
算歧义，请使用括号来处理该运算的优先级，如 ``2 ** (2 ** 3)`` 。

+---------------------------------------+-----------------------------------------------------------------------------+
| **Operator**                          | **Description**                                                             |
+=======================================+=============================================================================+
| ``(`` ``)``                           | Grouping (highest priority)                                                 |
|                                       |                                                                             |
|                                       | Parentheses are not really an operator, but allow you to explicitly specify |
|                                       | the precedence of an operation.                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x[index]``                          | Subscription                                                                |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x.attribute``                       | Attribute reference                                                         |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``foo()``                             | Function call                                                               |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``await x``                           | `Awaiting signals or coroutines`_                                           |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x is Node``                       | Type checking                                                               |
| | ``x is not Node``                   |                                                                             |
|                                       | See also :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>`    |
|                                       | function.                                                                   |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x ** y``                            | Power                                                                       |
|                                       |                                                                             |
|                                       | Multiplies ``x`` by itself ``y`` times, similar to calling                  |
|                                       | :ref:`pow() <class_@GlobalScope_method_pow>` function.                      |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``~x``                                | Bitwise NOT                                                                 |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``+x``                              | Identity / Negation                                                         |
| | ``-x``                              |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x * y``                           | Multiplication / Division / Remainder                                       |
| | ``x / y``                           |                                                                             |
| | ``x % y``                           | The ``%`` operator is additionally used for                                 |
|                                       | :ref:`format strings <doc_gdscript_printf>`.                                |
|                                       |                                                                             |
|                                       | **Note:** These operators have the same behavior as C++, which may be       |
|                                       | unexpected for users coming from Python, JavaScript, etc. See a detailed    |
|                                       | note after the table.                                                       |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x + y``                           | Addition (or Concatenation) / Subtraction                                   |
| | ``x - y``                           |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x << y``                          | Bit shifting                                                                |
| | ``x >> y``                          |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x & y``                             | Bitwise AND                                                                 |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x ^ y``                             | Bitwise XOR                                                                 |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x | y``                             | Bitwise OR                                                                  |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x == y``                          | Comparison                                                                  |
| | ``x != y``                          |                                                                             |
| | ``x < y``                           | See a detailed note after the table.                                        |
| | ``x > y``                           |                                                                             |
| | ``x <= y``                          |                                                                             |
| | ``x >= y``                          |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x in y``                          | Inclusion checking                                                          |
| | ``x not in y``                      |                                                                             |
|                                       | ``in`` is also used with the for_ keyword as part of the syntax.            |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``not x``                           | Boolean NOT and its :ref:`unrecommended <boolean_operators>` alias          |
| | ``!x``                              |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x and y``                         | Boolean AND and its :ref:`unrecommended <boolean_operators>` alias          |
| | ``x && y``                          |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x or y``                          | Boolean OR and its :ref:`unrecommended <boolean_operators>` alias           |
| | ``x || y``                          |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``true_expr if cond else false_expr`` | Ternary if/else                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+
| ``x as Node``                         | `Type casting <casting_>`_                                                  |
+---------------------------------------+-----------------------------------------------------------------------------+
| | ``x = y``                           | Assignment (lowest priority)                                                |
| | ``x += y``                          |                                                                             |
| | ``x -= y``                          | You cannot use an assignment operator inside an expression.                 |
| | ``x *= y``                          |                                                                             |
| | ``x /= y``                          |                                                                             |
| | ``x **= y``                         |                                                                             |
| | ``x %= y``                          |                                                                             |
| | ``x &= y``                          |                                                                             |
| | ``x |= y``                          |                                                                             |
| | ``x ^= y``                          |                                                                             |
| | ``x <<= y``                         |                                                                             |
| | ``x >>= y``                         |                                                                             |
+---------------------------------------+-----------------------------------------------------------------------------+

.. note::

    一些运算符的运算机制可能会与你所预期的运算机制有所不同：

    1. 若运算符 ``/`` 两端的数值均为 :ref:`int <class_int>`，则进行整数除法而非浮点数除法。例如： ``5 /2 == 2`` 中该算式的结果为 ``2`` 而非 ``2.5`` 。若希望进行浮点数运算，请将该
       运算符两端的其中一个数值的类型改为 :ref:`float <class_float>` ，如直接使用浮点数（``x / 2.0``）、转换类型（``float(x) / y``）、乘以 ``1.0`` （``x * 1.0 / y``）等。
    2. 运算符 ``%`` 仅适用于整型数值的取余运算，对于小数的取余运算，请使用 :ref:`fmod() <class_@GlobalScope_method_fmod>` 方法。
    3. 对于负值， ``%`` 运算符和 ``fmod()`` 函数会使用 `截断算法 <https://en.wikipedia.org/wiki/Truncation>`_ 进行运算，而非向负无穷大舍入，此时余数会带有
       符号（即余数可能为负）。如果你需要数学意义上的余数，请改用 :ref:`posmod() <class_@GlobalScope_method_posmod>` 和 :ref:`fposmod() <class_@GlobalScope_method_fposmod>` 函数。
    4. ``==`` 和 ``!=`` 运算符在有些情况下允许比较不同类型的值（例如，``1 == 1.0`` 的结果为真），但在其他情况下可能会发生运行时错误。若你
       不能确定操作数的类型，可使用 :ref:`is_same() <class_@GlobalScope_method_is_same>` 函数来进行安全比较（但请注意，该函数对类型和
       引用更加严格）。要比较浮点数，请改用 :ref:`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` 和 :ref:`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` 函数。

字面量
--------

+---------------------------------+-------------------------------------------+
| **Example(s)**                  | **Description**                           |
+---------------------------------+-------------------------------------------+
| ``null``                        | Null value                                |
+---------------------------------+-------------------------------------------+
| ``false``, ``true``             | Boolean values                            |
+---------------------------------+-------------------------------------------+
| ``45``                          | Base 10 integer                           |
+---------------------------------+-------------------------------------------+
| ``0x8f51``                      | Base 16 (hexadecimal) integer             |
+---------------------------------+-------------------------------------------+
| ``0b101010``                    | Base 2 (binary) integer                   |
+---------------------------------+-------------------------------------------+
| ``3.14``, ``58.1e-10``          | Floating-point number (real)              |
+---------------------------------+-------------------------------------------+
| ``"Hello"``, ``'Hi'``           | Regular strings                           |
+---------------------------------+-------------------------------------------+
| ``"""Hello"""``, ``'''Hi'''``   | Triple-quoted regular strings             |
+---------------------------------+-------------------------------------------+
| ``r"Hello"``, ``r'Hi'``         | Raw strings                               |
+---------------------------------+-------------------------------------------+
| ``r"""Hello"""``, ``r'''Hi'''`` | Triple-quoted raw strings                 |
+---------------------------------+-------------------------------------------+
| ``&"name"``                     | :ref:`StringName <class_StringName>`      |
+---------------------------------+-------------------------------------------+
| ``^"Node/Label"``               | :ref:`NodePath <class_NodePath>`          |
+---------------------------------+-------------------------------------------+

也有两种长得像字面量，但实际上不是字面量的量：

+---------------------------------+-------------------------------------------+
| **Example**                     | **Description**                           |
+---------------------------------+-------------------------------------------+
| ``$NodePath``                   | Shorthand for ``get_node("NodePath")``    |
+---------------------------------+-------------------------------------------+
| ``%UniqueNode``                 | Shorthand for ``get_node("%UniqueNode")`` |
+---------------------------------+-------------------------------------------+

整数和浮点数可用 ``_`` 进行分隔，使其更加易读。以下表示数字的方法均有效::

    12_345_678  # Equal to 12345678.
    3.141_592_7  # Equal to 3.1415927.
    0x8080_0000_ffff  # Equal to 0x80800000ffff.
    0b11_00_11_00  # Equal to 0b11001100.

**常规字符串字面量** 内可包含以下转义序列：

+---------------------+---------------------------------+
| **Escape sequence** | **Expands to**                  |
+---------------------+---------------------------------+
| ``\n``              | Newline (line feed)             |
+---------------------+---------------------------------+
| ``\t``              | Horizontal tab character        |
+---------------------+---------------------------------+
| ``\r``              | Carriage return                 |
+---------------------+---------------------------------+
| ``\a``              | Alert (beep/bell)               |
+---------------------+---------------------------------+
| ``\b``              | Backspace                       |
+---------------------+---------------------------------+
| ``\f``              | Formfeed page break             |
+---------------------+---------------------------------+
| ``\v``              | Vertical tab character          |
+---------------------+---------------------------------+
| ``\"``              | Double quote                    |
+---------------------+---------------------------------+
| ``\'``              | Single quote                    |
+---------------------+---------------------------------+
| ``\\``              | Backslash                       |
+---------------------+---------------------------------+
| ``\uXXXX``          | UTF-16 Unicode codepoint        |
|                     | ``XXXX``                        |
|                     | (hexadecimal, case-insensitive) |
+---------------------+---------------------------------+
| ``\UXXXXXX``        | UTF-32 Unicode codepoint        |
|                     | ``XXXXXX``                      |
|                     | (hexadecimal, case-insensitive) |
+---------------------+---------------------------------+

有两种方法可以表示 ``0xFFFF`` 以上的转义 Unicode 字符：

- 使用 `UTF-16 代理 <https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ 对 ``\uXXXX\uXXXX`` 表示。
- 使用单个 UTF-32 码位 ``\UXXXXXX`` 表示。

此外，在字符串中使用 ``\`` 后换行可以让斜杠后的文字自动换行，而无需在字符串中插入换行符。

使用某一种引号（如 ``"``）构成的字符串，无需转义即可包含另一种引号（如 ``'``），而三引号字符串在与其他字符串边缘不相邻的情况下，最多可避免连续两个同种引号的转义。

**原始字符串字面量** 始终按照源代码中出现的方式对字符串进行编码，特别适用于正则表达式当中。原始字符串
虽不处理转义序列，但可以识别 ``\\`` 和 ``\"`` （ ``\'`` ）等字符，并将其替换为其自身。一个字符串内可以含有一对相匹配的引号，但这些引号前面必须有一个反斜杠才可以让字符串包含它们。

::

    print("\tchar=\"\\t\"")  # 打印 `    char="\t"`
    print(r"\tchar=\"\\t\"") # 打印 `\tchar=\"\\t\"`

.. note::

   而有些字符串却不能使用原始字符串字面量来表示：不能在字符串末尾有奇数个反斜杠，不能在字符串内部有未转义的开引号。但在实际应用中，这些问题
   并不重要，因为你可以通过使用不同类型的引号，或者与普通字符串字面量进行拼接，来解决这个问题。

GDScript 也支持 :ref:`GDScript 格式字符串 <doc_gdscript_printf>`

注解
-----------

注解是 GDScript 中的一类特殊标记，用来修饰脚本或脚本中的代码，影响 Godot 引擎或编辑器对该脚本或代码的所产生的效果。

每个注解均以 ``@`` 符号开头，加以注解名称而构成。有关注解的详细说明及其使用范例，请参考 :ref:`GDScript class reference <class_@GDScript>` 。

比如，可以将变量导出到编辑器中::

    @export_range(1, 100, 1, "or_greater")
    var ranged_var: int = 50

要获取更多关于导出属性的信息，请参阅 :ref:`GDScript exports <doc_gdscript_exports>`。

所有与注解要求传入的参数类型相符、位置相配的常量表达式均可作为该注解的参数传入其中::

    const MAX_SPEED = 120.0

    @export_range(0.0, 0.5 * MAX_SPEED)
    var initial_speed: float = 0.25 * MAX_SPEED

注解既可单行修饰，也可多行修饰，修饰离该注解最近的非注解语句。注解可携带参数，每个参数均在注解名后的括号内，彼此之间用逗号隔开。

以下两个示例效果等价::

    @annotation_a
    @annotation_b
    var variable

    @annotation_a @annotation_b var variable

.. _doc_gdscript_onready_annotation:

``@onready`` 注解
~~~~~~~~~~~~~~~~~~~~~~~

使用节点时，经常会需要将场景中某一部分的引用存放在变量中。由于场景只有在进入活动场景树时才会进行正确配置，故而仅在调用 ``Node._ready()`` 时才能获得子节点。

::

    var my_label


    func _ready():
        my_label = get_node("MyLabel")

这种操作较为麻烦，而且节点和外部引用越多，操作起来就会越显不便。为此，GDScript 提供了 ``@onready`` 注解 ，将成员变量
的初始化操作推迟到该节点调用 ``_ready()`` 的时刻进行。使用该注解，可以用一行代码替换掉上面的几行代码::

    @onready var my_label = get_node("MyLabel")

.. warning::

    同时使用 ``@onready`` 和 ``@export`` 这两个注解去修饰同一个变量，其效果并不会如你所愿，因为 ``@onready`` 注解会使
    该变量的默认值在 ``@export`` 注解起效后被赋值，导致该默认值被 ``@onready`` 的效果所覆盖::

        @export var a = "init_value_a"
        @onready @export var b = "init_value_b"

        func _init():
            prints(a, b) # init_value_a <null>

        func _notification(what):
            if what == NOTIFICATION_SCENE_INSTANTIATED:
                prints(a, b) # exported_value_a exported_value_b

        func _ready():
            prints(a, b) # exported_value_a init_value_b

    为此，本引擎提供了 ``ONREADY_WITH_EXPORT`` 警告选项，默认将该操作作为编辑器错误进行处理。我们并不推荐关闭或忽略该警告选项。

注释
--------

``#`` 所在行的所有内容都会被忽略，会视为注释进行处理。

::

    # 这是一个注释

.. tip::

    在 Godot 的脚本编辑器中，一些特殊关键字会在注释中高亮显示以提醒用户:

    - **关键提示** *(标红)*: ``ALERT``, ``ATTENTION``, ``CAUTION``,
      ``CRITICAL``, ``DANGER``, ``SECURITY``
    - **警告提示** *(标黄)*: ``BUG``, ``DEPRECATED``, ``FIXME``,
      ``HACK``, ``TASK``, ``TBD``, ``TODO``, ``WARNING``
    - **一般提示** *(标绿)*: ``INFO``, ``NOTE``, ``NOTICE``, ``TEST``,
      ``TESTING``

    这些关键字均大小写敏感，故需要全大写以保证能被引擎所识别：

    ::

        # 在下面的示例中，“TODO”默认显示为黄色。
        # 关键字后面的“:”符号不是必需的，但经常使用。

        # TODO: 添加更多物品供玩家选择

    可在编辑器设置的 **文本编辑器 > 主题 > 注释标记** 部分中更改突出显示的关键字列表及其颜色。

使用两个哈希符号（``##``）而不是一个（``#``）来添加 *文档注释*，该注释将出现在脚本文档和导出变量的检查器描述中。文档注释必须直接放
置在可记录项目（例如成员变量）的 *上方*，或者放置在文件的顶部。还提供专用格式选项。有关详细信息，请参阅 :ref:`doc_gdscript_documentation_comments`。
::
    ## 该注释将出现在脚本文档中。
    var value

    ## 此注释将出现在检查器工具提示和文档中。
    @export var exported_value

代码块
------------

代码区块是一种特殊类型的注释，脚本编辑器将其理解为 *可折叠区块*，即在编写代码区块注释后，可以通过
点击注释左侧出现的箭头来折叠和展开该区块。该箭头用一个紫色方块包围起来，以区别于标准的代码折叠。

语法如下:

::

    # 重要提示：“#”和“region”或“endregion”之间不能有空格

    # 没有描述的代码块：
    #region
    ...
    #endregion

    # 有描述的代码块：
    #region 这里是代码块描述
    ...
    #endregion

.. tip::

    要快速创建代码区域，请在脚本编辑器中选择几行，右键单击所选内容，然后选择**创建代码区域**，将自动选择区域描述进行编辑。

    可将代码区块嵌套在其他代码区块内。

以下为代码区块的具体使用示例：

::

    # 该注释位于代码区域之外。折叠时将可见。
    #region 地形生成
    # 该注释位于代码区域内。折叠后将不可见。
    func generate_lakes():
        pass

    func generate_hills():
        pass
    #endregion

    #region 地形生成
    func place_vegetation():
        pass

    func place_roads():
        pass
    #endregion

代码区块可将大块代码组织成更容易理解的部分，但注意：外部编辑器通常不支持该特性。因此即便不依赖代码区块，也要确保你的代码易于理解。

.. note::

    单独的函数与被缩进的部分（如 ``if`` 和 ``for``） *始终* 可以在脚本编辑器中折叠，此时应避免使用代码区块来包含这些可
    始终折叠起来的部分，执意使用亦可，但也并不会带来太多好处。若要将多个元素分组在一起，使用代码区块效果最佳。

行间语句接续
-----------------

在GDScript中，一行语句可通过反斜杠（ ``\`` ）接续到下一行。将反斜杠加在一行语句末尾可将该行代码与下一行代码相衔接。如：

::

    var a = 1 + \
    2

可按以下方式对单个语句行进行多行接续：

::

    var a = 1 + \
    4 + \
    10 + \
    4

.. _doc_gdscript_builtin_types:

内置类型
--------------

内置类型分配在栈上，按值传递，在每次赋值或将其作为参数传递给函数时均会复制其值，例外：对象 ``Object``、``Array``、``Dictionary`` 以及密存数
组（如 ``PackedByteArray`` ），这些类型的值按引用传递，其实例的值相互共享。数组、字典以及部分对象（``Node``、``Resource``）均有 ``duplicate()`` 方法，允许对其具体值进行复制操作。

基本内置类型
~~~~~~~~~~~~~~~~~~~~

GDScript 中的变量可赋以不同内置类型的值。

null
^^^^

``null`` 为空数据类型，既不包含任何信息，也不能赋值为其他任何值。

只有从 Object 继承的类型才能具有 ``null`` 值（因此，Object 被称为“可空”类型）。 :ref:`变体类型 <doc_variant_class>` 必须始终具有有效值，因此不能具有 ``null`` 值。

:ref:`bool <class_bool>`
^^^^^^^^^^^^^^^^^^^^^^^^

“boolean”（布尔）的缩写，只能包含 ``true`` 或 ``false``。

:ref:`int <class_int>`
^^^^^^^^^^^^^^^^^^^^^^

英文“integer”（整数）的缩写，存储整数（正整数和负整数）。存储的是 64 位值，等效于 C++ 中的 ``int64_t``。

:ref:`float <class_float>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

使用浮点值存储实数，包括小数。存储的是 64 位值，等效于 C++ 中的 ``double``。注意：目前 ``Vector2`` 、 ``Vector3`` 、 ``PackedFloat32Array`` 等数据结构存储的是 32 位单精度 ``float`` 值。

:ref:`String <class_String>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Unicode 格式 <https://en.wikipedia.org/wiki/Unicode>`_ 的字符序列。

:ref:`StringName <class_StringName>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

不可变字符串，一个实例仅允许拥有一个名称。该类型的实例创建起来较慢，在多线程环境下可能会导致锁等待。不过，该类型的实例比较起来比字符串快，非常适合在字典中作为键名使用。

:ref:`NodePath <class_NodePath>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

节点或节点属性的预解析路径，可以轻松地赋值成字符串，亦或从字符串中转换为节点路径。节点路径可用于与节点树交互以获取节点，亦或通过诸如 :ref:`Tweens <class_Tween>` 等方式来影响属性。

内置向量类型
~~~~~~~~~~~~~~~~~~~~~

:ref:`Vector2 <class_Vector2>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2D 向量类型，包含 ``x`` 和 ``y`` 两个字段，也可像访问数组元素一样访问这两个字段。

:ref:`Vector2i <class_Vector2i>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

同 Vector2，但其分量均为整型数值，非常适用于制作2D网格显示物品功能。

:ref:`Rect2 <class_Rect2>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

2D 矩形类型，包含两个向量字段：``position`` 和 ``size`` 。还包含一个 ``end`` 字段，即 ``position + size``。

:ref:`Vector3 <class_Vector3>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3D 向量类型，包含 ``x`` 、 ``y`` 和 ``z`` 这三个字段，也可以像访问数组元素一样访问这些字段。

:ref:`Vector3i <class_Vector3i>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

同 Vector3 ，但其分量均为整型数值，可用于为 3D 网格中的每个物品编制索引。

:ref:`Transform2D <class_Transform2D>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

用于 2D 线性变换的3x2矩阵。

:ref:`Plane <class_Plane>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

3D 平面类型的标准形式，包含一个向量字段 ``normal`` 以及一个 标量距离 ``d`` 。

:ref:`Quaternion <class_Quaternion>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

四元数是一种用于表示 3D 旋转的数据类型，对于内插旋转十分有用。

:ref:`AABB <class_AABB>`
^^^^^^^^^^^^^^^^^^^^^^^^

轴对齐边界框（或 3D 边框），包含两个向量字段: ``position`` 和 ``size``。 还包含一个 ``end`` 字段, 即 ``position + size``。

:ref:`Basis <class_Basis>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

3×3矩阵，用于 3D 旋转与缩放。其包含3个向量字段（ ``x`` , ``y`` 和 ``z`` ），且可以像3D向量一样按索引访问这些向量字段。

:ref:`Transform3D <class_Transform3D>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3D 线性变换，包含一个 ``Basis``（基）字段 ``basis`` 和一个 ``Vector3`` 字段 ``origin``。

引擎内置类型
~~~~~~~~~~~~~~~~~~~~~

:ref:`Color <class_Color>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

颜色数据类型包含 ``r`` 、 ``g`` 、 ``b`` 、 ``a`` 四个字段，也可以用 ``h`` 、 ``s`` 、 ``v`` 这三个字段来分别访问色相、饱和度、明度。

:ref:`RID <class_RID>`
^^^^^^^^^^^^^^^^^^^^^^

资源ID（RID）。服务使用通用的 RID 来引用不透明数据。

:ref:`Object <class_Object>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

所有非内置类型的基类型。

容器内置类型
~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`Array <class_Array>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

任意对象类型的泛型序列，包括其他数组或字典（见下文）。数组可以动态调整大小，其索引从 ``0`` 开始，索引为负整数时则表示从数组尾部开始计数。

::

    var arr = []
    arr = [1, 2, 3]
    var b = arr[1] # 这是2
    var c = arr[arr.size() - 1] # 这是3
    var d = arr[-1] # 与上一行相同，但更短
    arr[0] = "Hi!" # 与上一行相同，但更短
    arr.append(4) # 数组现在是["Hi!", 2, 3, 4].

类型化数组
^^^^^^^^^^^^

向类型化数组中写入数据时，Godot 会检查每个元素是否与该数组所指定的类型相匹配，因此类型化数
组不能含有无效数据。而诸如 ``front()`` 和 ``back()`` 等方法，虽然 GDScript 静态分析器会将类型化数组考虑在内，却仍会返回 ``Variant`` 类型的数值。

类型化数组通过 ``Array[Type]`` 指定，其中类型 ``Type`` 可以是 ``Variant`` 类型、内置类型，也可以是用户自定义类型、枚举类型等。不支持类型化数组嵌套（如 ``Array[Array[int]]`` ）。

::

    var a: Array[int]
    var b: Array[Node]
    var c: Array[MyClass]
    var d: Array[MyEnum]
    var e: Array[Variant]

``Array`` 等价于 ``Array[Varaint]``

.. note::

    数组是按引用传递的，因此数组元素类型也是运行时变量引用的内存结构的一个属性。变量的静态类型限制了它可以引用的结构。因此，你 **不能** 为数组内的元素赋予不同的元素类型的值，即使该类型是数组所接受类型的子类型。

    If you want to *convert* a typed array, you can create a new array and use the
    
    若需要对类型化数组进行 **转型** ，可以创建一个新数组，并使用 :ref:`Array.assign() <class_Array_method_assign>` 方法::

        var a: Array[Node2D] = [Node2D.new()]

        # （正确）你可以将值添加到数组中，因为“Node2D”扩展了“Node”。
        var b: Array[Node] = [a[0]]

        # (错误) 你不能将“Array[Node2D]”分配给“Array[Node]”变量。
        b = a

        # (正确) 但您可以使用“assign()”方法来代替。与“=”运算符不同，
        # “assign()” 方法复制数组的内容，而不是引用。
        b.assign(a)

    ``Array``（``Array[Variant]``）则是例外，这样做可以保证用户使用的便捷性与与旧版本代码的兼容性。不过，非类型化的数组是不安全的。

压缩数组
^^^^^^^^^^^^^

GDScript 数组在内存中通过线性分配以提高运行速度，但在使用大型数组（包含数万个元素）时可能会导致内存碎片。如果在意这个问题，可以使用特定类型的压缩数组，这些数组只接受单个
数据类型，避免了内存碎片的同时使用的内存也更少。然而这些压缩数组是原子数组，运行起来通常要比通用数组慢，因此建议仅将压缩数组用于大型数据集当中:

- :ref:`PackedByteArray <class_PackedByteArray>`: 字节（从 0 到 255 的整数）数组。
- :ref:`PackedInt32Array <class_PackedInt32Array>`: 32位整数数组。
- :ref:`PackedInt64Array <class_PackedInt64Array>`: 64位整数数组。
- :ref:`PackedFloat32Array <class_PackedFloat32Array>`: 32位浮点数数组。
- :ref:`PackedFloat64Array <class_PackedFloat64Array>`: 64位浮点数数组。
- :ref:`PackedStringArray <class_PackedStringArray>`: 字符串数组。
- :ref:`PackedVector2Array <class_PackedVector2Array>`: :ref:`Vector2 <class_Vector2>` 类型的数组。
- :ref:`PackedVector3Array <class_PackedVector3Array>`: :ref:`Vector3 <class_Vector3>` 类型的数组。
- :ref:`PackedVector4Array <class_PackedVector4Array>`: :ref:`Vector4 <class_Vector4>` 类型的数组。
- :ref:`PackedColorArray <class_PackedColorArray>`: :ref:`Color <class_Color>` 类型的数组。

:ref:`Dictionary（字典） <class_Dictionary>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

关联容器，其内部数值通过与之对应的唯一的键进行引用。

::

    var d = {4: 5, "A key": "A value", 28: [1, 2, 3]}
    d["Hi!"] = 0
    d = {
        22: "value",
        "some_key": 2,
        "other_key": [2, 3, 4],
        "more_key": "Hello"
    }

字典也支持 Lua 风格的 table 语法。Lua 风格的 GDScript 字典语法在标记字符串键时，使用的是 ``=`` 而非 ``:`` ，且不使用引号（这样要写的东西会稍微少一些）。但请注意，以这种形式
编写的键和 GDScript 标识符一样不能以数字开头，且必须为字面量。

::

    var d = {
        test22 = "value",
        some_key = 2,
        other_key = [2, 3, 4],
        more_key = "Hello"
    }

若要向现有字典添加键，可以像访问现有键一样访问要添加的键，并给其赋值::

    var d = {} # 创建一个空字典。
    d.waiting = 14 # 添加字符串“waiting”作为键并为其分配值 14。
    d[4] = "hello" # 添加整数 4 作为键，并将字符串“hello”指定为其值。
    d["Godot"] = 4.3 # 添加字符串“Godot”作为键并为其分配值 4.3。
    var test = 4
    # 通过使用动态键索引字典来打印“hello”。
    # 这与“d.test”不同。括号语法相当于
    # `d.test` 就是 `d["test"]`.
    print(d[test])

.. note::

    方括号语法不仅可以用在 Dictionary 上，而且还可以用来存取任何 :ref:`class_Object` 的属性。不过要注意：尝试读
    取不存在的属性会引发脚本错误。要避免这一点，可换用 :ref:`Object.get() <class_Object_method_get>` 和 :ref:`Object.set() <class_Object_method_set>` 方法。

:ref:`Signal（信号） <class_Signal>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

信号由对象发出，并由对象所监听。 Signal 类型可以用于将信号广播者作为参数进行传递。

信号可以直接从对象实例中进行引用，如 ``$Button.button_up`` 。

:ref:`Callable <class_Callable>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

可调用体包含一个对象及其某个函数，适用于将函数作为数值传递（例如：将可调用体用于信号连接）。

像引用成员属性那样引用一个方法的签名会返回可调用体。 如 ``var x = $Sprite2D.rotate`` 会将变量 ``x`` 赋值为一个可调用体，该可调用体含有对 ``$Sprite2D`` 对象的方法 ``rotate()`` 的引用。

可以调用 ``call`` 方法来调用可调体所指向的方法，如： ``x.call(PI)`` 。

变量
---------

变量可以作为类成员存在，也可以作为函数的局部变量存在，用 ``var`` 关键字创建，可以在初始化时指定一个值。

::

    var a # 默认情况下，数据类型为“null”。
    var b = 5
    var c = 3.8
    var d = b + c # 变量总是按直接顺序初始化（见下文）。

变量可进行类型指定。指定类型时，将强制该变量始终容纳与被指定类型相同类型的数据。试图分配与该类型不兼容的值将触发报错。

在变量声明中，在变量名后面使用 ``:`` + ``类型名`` 来指定类型。

::

    var my_vector2: Vector2
    var my_node: Node = Sprite2D.new()

如果在声明中初始化变量，则可以推断变量类型，在此情况下可省略类型名称::

    var my_vector2 := Vector2() # “my_vector2”的类型为“Vector2”。
    var my_node := Sprite2D.new() # “my_node”的类型为“Sprite2D”。

类型推断只有在指定的值具有定义的类型时才能通过检查，否则将触发报错。

有效的类型有：

- 内置类型（如 Array 、 Vector2、 int、 String 等）。
- 引擎自带类型（如 Node 、 Resource 、 Reference 等）。
- 包含脚本资源的常量名（如 ``MyScript`` ，前提是声明了 ``const MyScript = preload("res://my_script.gd")`` ）。
- 在同一个脚本中的其他内部类，此时需要注意作用域（比如：在相同作用域内，在 ``class InnerClass`` 中声明 ``class NestedClass`` 则会得到 ``InnerClass.NestedClass`` ）。
- 通过 ``class_name`` 关键字声明的脚本类。
- 自动加载的节点——单例节点。

.. note::

    虽然 ``Variant`` 类型被引擎视作有效类型，但其并不是一个确切的类型，只是一个“没有固定类型”的代名词。使用 ``Variant`` 类型很有可能会导致报错，因此引擎默认不会对该类型进行推断。
    你可以在项目设置中将该检查关闭，或将其设为警告。详见 :ref:`<doc_gdscript_warning_system>` 。

初始化顺序
~~~~~~~~~~~~~~~~~~~~

成员变量的初始化顺序如下：

1. 变量根据其静态类型，取值为 ``null`` （无类型变量和对象）或类型的默认值（ ``int`` 为 ``0`` 、 ``bool`` 为 ``false`` 等）。
2. 指定的值按照脚本中变量的顺序从上到下分配。

   - （仅适用于 ``Node`` 派生类）如果 ``@onready`` 注释应用于变量，则其初始化将推迟到步骤 5。

3. 所有非 ``@onready`` 成员变量均完成定义时调用 ``_init()`` 方法。
4. 初始化场景和资源时，赋导出的值。
5.（仅适用于 ``Node`` 派生类） ``@onready`` 变量被初始化。
6.（仅适用于 ``Node`` 派生类）如果定义，则调用 ``_ready()`` 方法。

.. warning::

    复杂表达式也能够作为变量的初始化器，其中也包括函数调用。请确保初始化变量时变量的声明顺序正确，否则对应的值可能会被覆盖。例如::

        var a: int = proxy("a", 1)
        var b: int = proxy("b", 2)
        var _data: Dictionary = {}

        func proxy(key: String, value: int):
            _data[key] = value
            print(_data)
            return value

        func _init() -> void:
            print(_data)

    会在控制台中打印出::

        { "a": 1 }
        { "a": 1, "b": 2 }
        {  }

    解决这个问题只需将 ``_data`` 变量的定义移动到 ``a`` 的定义之前，或者移除空字典的赋值（ ``={}`` ）。

静态变量
~~~~~~~~~~~~~~~~

成员变量可以声明为静态成员变量::

    static var a

S静态变量直属于类而非类的实例，即静态变量可以在多个类实例之间共享数据，这一点与一般的成员变量有所区别。

在类内，静态函数和非静态函数都可以访问静态变量。在类外，可以通过使用类名或类的实例来访问静态变量（后者并不推荐，因为可读性较低）。

.. note::

    ``@export`` 注解和 ``@onready`` 注解不能修饰静态成员变量。局部变量不能声明为静态局部变量。

下例中，我们定义了一个 ``Person`` 类，声明了一个静态成员变量 ``max_id`` 。在游戏中，我们可以增加 ``max_id`` 这个静态成员变量来让我们更容易追踪游戏中 ``Person`` 实例的数量。

::

    # person.gd
    class_name Person

    static var max_id = 0

    var id
    var name

    func _init(p_name):
        max_id += 1
        id = max_id
        name = p_name

I下面我们创建两个 ``Person`` 类的实例，会发现类和实例具有相同的 ``max_id`` 值，这是因为该成员变量是静态成员变量，能够在每个实例中访问。

::

    # test.gd
    extends Node

    func _ready():
        var person1 = Person.new("John Doe")
        var person2 = Person.new("Jane Doe")

        print(person1.id) # 1
        print(person2.id) # 2

        print(Person.max_id)  # 2
        print(person1.max_id) # 2
        print(person2.max_id) # 2

静态变量可以指定类型、设置 setter 函数和 getter 函数::

    static var balance: int = 0

    static var debt: int:
        get:
            return -balance
        set(value):
            balance = -value

父类的静态成员变量也可以在子类中访问::

    class A:
        static var x = 1

    class B extends A:
        pass

    func _ready():
        prints(A.x, B.x) # 1 1
        A.x = 2
        prints(A.x, B.x) # 2 2
        B.x = 3
        prints(A.x, B.x) # 3 3

``@static_unload`` 注解
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GDScript 的类均为资源，而静态变量会阻止脚本资源卸载，即便该脚本所对应的类的实例以及对该实例引用并不存在，静态变量依旧会阻止该脚本资源卸载。在静态变量存储大量数据，同时还含有对其他对象的引用（比如场景）的情况下，更需要引起格外重视。你需要手动清理掉这些数据，亦或是使用 :ref:`@static_unload <class_@GDScript_annotation_@static_unload>` 注解，让静态变量在不存储重要数据时得到重置。

.. warning::

    目前由于某个漏洞导致含静态成员变量的脚本实例即使使用了 ``@static_unload`` 注解也无法被清除的问题。

注意： ``@static_unload`` 注解修饰整个脚本（包括内部类），需置于脚本最开头，且位于 ``class_name`` 和 ``extends`` 关键字之前::

    @static_unload
    class_name MyNode
    extends Node

亦可见 `静态函数`_ 和 `静态构造函数`_ 。

类型转换
~~~~~~~~

赋予给指定了类型的变量的值必须具有与其类型相兼容的类型。若需要将值强制转换为特定类型，特别是对于对象类型而言要进行转型，则可以使用强制转型运算符 ``as`` 。

如果值是对象类型，且为与目标类型相同的类型，亦或为目标类型的子类型，则进行转型后会得到同一个对象。

::

    var my_node2D: Node2D
    my_node2D = $Sprite2D as Node2D # 之所以有效，是因为 Sprite2D 是 Node2D 的子类型。

如果该值的类型不是目标类型的子类型，则强制转型操作将产生 ``null`` 值。

::

    var my_node2D: Node2D
    my_node2D = $Button as Node2D # 结果为“null”，因为 Button 不是 Node2D 的子类型。

对于内置类型，如果允许，则将对其进行强制转型，否则将触发报错。

::

    var my_int: int
    my_int = "123" as int # The string can be converted to int.
    my_int = Vector2() as int # A Vector2 can't be converted to int, this will cause an error.

与场景树进行交互时，在获取节点这方面，强制转型也更加类型安全，十分有用::

    # 将推断该变量的类型为 Sprite2D。
    var my_sprite := $Character as Sprite2D

    # 如果 $AnimPlayer 不是 AnimationPlayer，即使它具有“play()”方法，也会失败。
    ($AnimPlayer as AnimationPlayer).play("walk")

常量
---------

常量是游戏运行时不可更改的量，其值在编译时必须已知，可使用 ``const`` 关键字为常量值赋予名称。尝试为常量重新赋值将会触发报错。

建议使用常量来储存不应更改的值。

::

    const A = 5
    const B = Vector2(20, 20)
    const C = 10 + 20 # 常量的表达。
    const D = Vector2(20, 30).x # 常数的值：20。
    const E = [1, 2, 3, 4][0] # 常量的值：1。
    const F = sin(20) # “sin()”可以用在常量表达式中。
    const G = x + 20 # 无效的;这不是一个常量表达式！
    const H = A + 20 # 常量的值：25（“A”是常量）。

常量的类型虽然可以从赋予的值中推断出来，但也可以通过显式添加类型来指定::

    const A: int = 5
    const B: Vector2 = Vector2()

赋予与指定的类型不相容的值将触发报错。

也可以在函数内使用常量来声明一些局部魔法值。

枚举
~~~~~

枚举实质上是常量的简写，适用于为某些常量连续赋整数值。

::

    enum {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT}

    # 等同于：
    const TILE_BRICK = 0
    const TILE_FLOOR = 1
    const TILE_SPIKE = 2
    const TILE_TELEPORT = 3

若将名称传递给枚举，则该枚举将会把所有键纳入该名称的 :ref:`Dictionary <class_Dictionary>` 中，即字典中的所有常方法均可用于具名枚举当中。

.. important:: 
    从 Godot 3.1 开始，不会再将具名枚举的键注册为全局常量，此后，应在枚举常量前缀以枚举名的形式来访问枚举内的枚举常量（ ``Name.KEY`` ）；见后面的例子。

::

    enum State {STATE_IDLE, STATE_JUMP = 5, STATE_SHOOT}

    # 等同于：
    const State = {STATE_IDLE = 0, STATE_JUMP = 5, STATE_SHOOT = 6}
    # 使用 State.STATE_IDLE 等访问值。

    func _ready():
        # 使用 Name.KEY 访问值，打印“5”
        print(State.STATE_JUMP)
        # 使用字典方法：
        # 打印 '["STATE_IDLE", "STATE_JUMP", "STATE_SHOOT"]'
        print(State.keys())
        # 打印 '{ "STATE_IDLE": 0, "STATE_JUMP": 5, "STATE_SHOOT": 6 }'
        print(State)
        # 打印 '[0, 5, 6]'
        print(State.values())

如果未将值分配给枚举的键，则将为其分配前一个值加一，如果它是枚举中的第一个条目，则为 ``0`` 。允许多个键具有相同的值。

函数
---------

函数始终属于 `类 <Classes_>`_ 。查找变量时，函数作用域的查找顺序是：局部 → 类成员 → 全局。引擎始终允许用 ``self`` 作为访问本类及本类成员的关键字，但该关键
字在一般情况下并无添加的必要（与 Python 不同，在 GDScript 中 *不应该*将 ``self`` 作为函数的第一个参数传递）。

::

    func my_function(a, b):
        print(a)
        print(b)
        return a + b  # 返回值是可选的；如果没有它，则返回“null”。

函数可以在任何时候用 ``return`` 返回一个值，默认的返回值为 ``null`` 。

若函数体只含一行语句，则可以将函数及其函数体缩在同一行语句内编写::

    func square(a): return a * a

    func hello_world(): print("Hello World")

    func empty_function(): pass

也可对函数参数及函数返回值进行类型指定。可使用与声明变量类似的方式添加参数的类型::

    func my_function(a: int, b: String):
        pass

如果函数参数具有默认值，则可以对该参数的类型进行推断::

    func my_function(int_arg := 42, String_arg := "string"):
        pass

可以在参数列表之后使用箭头标记（ ``->`` ）来指定函数的返回值类型::

    func my_int_function() -> int:
        return 0

有返回类型的函数 **必须** 返回与返回值类型相匹配的值。将返回值类型设置为 ``void`` 表示该函数不返回任何东西。这种函数称为 *void* 函数，可以使用 ``return`` 关键字提前返回，但不能返回任何值。

::

    func void_function() -> void:
        return # 无法返回值。

.. note:: 
    非 *void* 函数 **必须** 返回一个值，如果你的代码具有分支语句（例如 ``if`` / ``else`` 构造），则所有可能的路径都必须有返回值。例如，如果在 ``if`` 块内有一个 ``return`` ，但在其后没有，则编辑器将抛出一个错误，因为如果该代码块    未执行，那么该函数将没有值进行有效返回。

引用函数
~~~~~~~~~~~~~~~~~~~~~

就 :ref:`Callable <class_Callable>` 对象而言，函数是一流的值。通过名称引用函数而不调用它会自动生成正确的可调用函数。这可用于将函数作为参数传递。

::

    func map(arr: Array, function: Callable) -> Array:
        var result = []
        for item in arr:
            result.push_back(function.call(item))
        return result

    func add1(value: int) -> int:
        return value + 1;

    func _ready() -> void:
        var my_array = [1, 2, 3]
        var plus_one = map(my_array, add1)
        print(plus_one) # 打印 “[2, 3, 4]”。

.. note::

   可调用对象 **必须** 使用 :ref:`call() <class_Callable_method_call>` 方法进行调用。您不能直接使用 ``()`` 运算符。实现此行为是为了避免直接函数调用的性能问题。

Lambda 函数
~~~~~~~~~~~~~~~~

Lambda 函数允许您声明不属于类的函数。相反，会创建一个 :ref:`Callable <class_Callable>` 对象并直接分配给变量。这对于创建可调用对象来传递而不污染类范围非常有用。

::

    var lambda = func (x):
        print(x)

要调用创建的 lambda，您可以使用 :ref:`call() <class_Callable_method_call>` 方法::

    lambda.call(42) # 打印 `42`.

Lambda functions can be named for debugging purposes (the name is displayed in the Debugger)::

    var lambda = func my_lambda(x):
        print(x)

You can specify type hints for lambda functions in the same way as for regular ones::

    var lambda := func (x: int) -> void:
        print(x)

Note that if you want to return a value from a lambda function, an explicit ``return``
is required (you can't omit ``return``)::

    var lambda = func (x): return x ** 2
    print(lambda.call(2)) # Prints `4`.

Lambda functions capture the local environment::

    var x = 42
    var lambda = func ():
        print(x) # Prints `42`.
    lambda.call()

.. warning::

    Local variables are captured by value once, when the lambda is created.
    So they won't be updated in the lambda if reassigned in the outer function::

        var x = 42
        var lambda = func (): print(x)
        lambda.call() # Prints `42`.
        x = "Hello"
        lambda.call() # Prints `42`.

    Also, a lambda cannot reassign an outer local variable. After exiting the lambda,
    the variable will be unchanged, because the lambda capture implicitly shadows it::

        var x = 42
        var lambda = func ():
            print(x) # Prints `42`.
            x = "Hello" # Produces the `CONFUSABLE_CAPTURE_REASSIGNMENT` warning.
            print(x) # Prints `Hello`.
        lambda.call()
        print(x) # Prints `42`.

    However, if you use pass-by-reference data types (arrays, dictionaries, and objects),
    then the content changes are shared until you reassign the variable::

        var a = []
        var lambda = func ():
            a.append(1)
            print(a) # Prints `[1]`.
            a = [2] # Produces the `CONFUSABLE_CAPTURE_REASSIGNMENT` warning.
            print(a) # Prints `[2]`.
        lambda.call()
        print(a) # Prints `[1]`.

Static functions
~~~~~~~~~~~~~~~~

A function can be declared static. When a function is static, it has no access to the instance member variables or ``self``.
A static function has access to static variables. Also static functions are useful to make libraries of helper functions::

    static func sum2(a, b):
        return a + b

Lambda functions cannot be declared static.

See also `Static variables`_ and `Static constructor`_.

Statements and control flow
---------------------------

Statements are standard and can be assignments, function calls, control
flow structures, etc (see below). ``;`` as a statement separator is
entirely optional.

Expressions
~~~~~~~~~~~

Expressions are sequences of operators and their operands in orderly fashion. An expression by itself can be a
statement too, though only calls are reasonable to use as statements since other expressions don't have side effects.

Expressions return values that can be assigned to valid targets. Operands to some operator can be another
expression. An assignment is not an expression and thus does not return any value.

Here are some examples of expressions::

    2 + 2 # Binary operation.
    -5 # Unary operation.
    "okay" if x > 4 else "not okay" # Ternary operation.
    x # Identifier representing variable or constant.
    x.a # Attribute access.
    x[4] # Subscript access.
    x > 2 or x < 5 # Comparisons and logic operators.
    x == y + 2 # Equality test.
    do_something() # Function call.
    [1, 2, 3] # Array definition.
    {A = 1, B = 2} # Dictionary definition.
    preload("res://icon.png") # Preload builtin function.
    self # Reference to current instance.

Identifiers, attributes, and subscripts are valid assignment targets. Other expressions cannot be on the left side of
an assignment.

if/else/elif
~~~~~~~~~~~~

Simple conditions are created by using the ``if``/``else``/``elif`` syntax.
Parenthesis around conditions are allowed, but not required. Given the
nature of the tab-based indentation, ``elif`` can be used instead of
``else``/``if`` to maintain a level of indentation.

::

    if (expression):
        statement(s)
    elif (expression):
        statement(s)
    else:
        statement(s)

Short statements can be written on the same line as the condition::

    if 1 + 1 == 2: return 2 + 2
    else:
        var x = 3 + 3
        return x

Sometimes, you might want to assign a different initial value based on a
boolean expression. In this case, ternary-if expressions come in handy::

    var x = (value) if (expression) else (value)
    y += 3 if y < 10 else -1

Ternary-if expressions can be nested to handle more than 2 cases. When nesting
ternary-if expressions, it is recommended to wrap the complete expression over
multiple lines to preserve readability::

    var count = 0

    var fruit = (
            "apple" if count == 2
            else "pear" if count == 1
            else "banana" if count == 0
            else "orange"
    )
    print(fruit)  # banana

    # Alternative syntax with backslashes instead of parentheses (for multi-line expressions).
    # Less lines required, but harder to refactor.
    var fruit_alt = \
            "apple" if count == 2 \
            else "pear" if count == 1 \
            else "banana" if count == 0 \
            else "orange"
    print(fruit_alt)  # banana

You may also wish to check if a value is contained within something. You can
use an ``if`` statement combined with the ``in`` operator to accomplish this::

    # Check if a letter is in a string.
    var text = "abc"
    if 'b' in text: print("The string contains b")

    # Check if a variable is contained within a node.
    if "varName" in get_parent(): print("varName is defined in parent!")

while
~~~~~

Simple loops are created by using ``while`` syntax. Loops can be broken
using ``break`` or continued using ``continue`` (which skips to the next
iteration of the loop without executing any further code in the current iteration):

::

    while (expression):
        statement(s)

for
~~~

To iterate through a range, such as an array or table, a *for* loop is
used. When iterating over an array, the current array element is stored in
the loop variable. When iterating over a dictionary, the *key* is stored
in the loop variable.

::

    for x in [5, 7, 11]:
        statement # Loop iterates 3 times with 'x' as 5, then 7 and finally 11.

    var names = ["John", "Marta", "Samantha", "Jimmy"]
    for name: String in names: # Typed loop variable.
        print(name) # Prints name's content.

    var dict = {"a": 0, "b": 1, "c": 2}
    for i in dict:
        print(dict[i]) # Prints 0, then 1, then 2.

    for i in range(3):
        statement # Similar to [0, 1, 2] but does not allocate an array.

    for i in range(1, 3):
        statement # Similar to [1, 2] but does not allocate an array.

    for i in range(2, 8, 2):
        statement # Similar to [2, 4, 6] but does not allocate an array.

    for i in range(8, 2, -2):
        statement # Similar to [8, 6, 4] but does not allocate an array.

    for c in "Hello":
        print(c) # Iterate through all characters in a String, print every letter on new line.

    for i in 3:
        statement # Similar to range(3).

    for i in 2.2:
        statement # Similar to range(ceil(2.2)).

If you want to assign values on an array as it is being iterated through, it
is best to use ``for i in array.size()``.

::

    for i in array.size():
        array[i] = "Hello World"


The loop variable is local to the for-loop and assigning to it will not change
the value on the array. Objects passed by reference (such as nodes) can still
be manipulated by calling methods on the loop variable.

::

    for string in string_array:
        string = "Hello World" # This has no effect

    for node in node_array:
        node.add_to_group("Cool_Group") # This has an effect

match
~~~~~

A ``match`` statement is used to branch execution of a program.
It's the equivalent of the ``switch`` statement found in many other languages, but offers some additional features.

.. warning::

    ``match`` is more type strict than the ``==`` operator. For example ``1`` will **not** match ``1.0``. The only exception is ``String`` vs ``StringName`` matching:
    for example, the String ``"hello"`` is considered equal to the StringName ``&"hello"``.

Basic syntax
^^^^^^^^^^^^

::

    match <test value>:
        <pattern(s)>:
            <block>
        <pattern(s)> when <pattern guard>:
            <block>
        <...>

Crash-course for people who are familiar with switch statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. Replace ``switch`` with ``match``.
2. Remove ``case``.
3. Remove any ``break``\ s.
4. Change ``default`` to a single underscore.

Control flow
^^^^^^^^^^^^

The patterns are matched from top to bottom.
If a pattern matches, the first corresponding block will be executed. After that, the execution continues below the ``match`` statement.

.. note::

    The special ``continue`` behavior in ``match`` supported in 3.x was removed in Godot 4.0.

The following pattern types are available:

- Literal pattern
    Matches a `literal <Literals_>`_::

        match x:
            1:
                print("We are number one!")
            2:
                print("Two are better than one!")
            "test":
                print("Oh snap! It's a string!")

- Expression pattern
    Matches a constant expression, an identifier, or an attribute access (``A.B``)::

        match typeof(x):
            TYPE_FLOAT:
                print("float")
            TYPE_STRING:
                print("text")
            TYPE_ARRAY:
                print("array")

- Wildcard pattern
    This pattern matches everything. It's written as a single underscore.

    It can be used as the equivalent of the ``default`` in a ``switch`` statement in other languages::

        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            _:
                print("It's not 1 or 2. I don't care to be honest.")

- Binding pattern
    A binding pattern introduces a new variable. Like the wildcard pattern, it matches everything - and also gives that value a name.
    It's especially useful in array and dictionary patterns::

        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            var new_var:
                print("It's not 1 or 2, it's ", new_var)

- Array pattern
    Matches an array. Every single element of the array pattern is a pattern itself, so you can nest them.

    The length of the array is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

    **Open-ended array**: An array can be bigger than the pattern by making the last subpattern ``..``.

    Every subpattern has to be comma-separated.

    ::

        match x:
            []:
                print("Empty array")
            [1, 3, "test", null]:
                print("Very specific array")
            [var start, _, "test"]:
                print("First element is ", start, ", and the last is \"test\"")
            [42, ..]:
                print("Open ended array")

- Dictionary pattern
    Works in the same way as the array pattern. Every key has to be a constant pattern.

    The size of the dictionary is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

    **Open-ended dictionary**: A dictionary can be bigger than the pattern by making the last subpattern ``..``.

    Every subpattern has to be comma separated.

    If you don't specify a value, then only the existence of the key is checked.

    A value pattern is separated from the key pattern with a ``:``.

    ::

        match x:
            {}:
                print("Empty dict")
            {"name": "Dennis"}:
                print("The name is Dennis")
            {"name": "Dennis", "age": var age}:
                print("Dennis is ", age, " years old.")
            {"name", "age"}:
                print("Has a name and an age, but it's not Dennis :(")
            {"key": "godotisawesome", ..}:
                print("I only checked for one entry and ignored the rest")

- Multiple patterns
    You can also specify multiple patterns separated by a comma. These patterns aren't allowed to have any bindings in them.

    ::

        match x:
            1, 2, 3:
                print("It's 1 - 3")
            "Sword", "Splash potion", "Fist":
                print("Yep, you've taken damage")

Pattern guards
^^^^^^^^^^^^^^

A *pattern guard* is an optional condition that follows the pattern list
and allows you to make additional checks before choosing a ``match`` branch.
Unlike a pattern, a pattern guard can be an arbitrary expression.

Only one branch can be executed per ``match``. Once a branch is chosen, the rest are not checked.
If you want to use the same pattern for multiple branches or to prevent choosing a branch with too general pattern,
you can specify a pattern guard after the list of patterns with the ``when`` keyword::

    match point:
        [0, 0]:
            print("Origin")
        [_, 0]:
            print("Point on X-axis")
        [0, _]:
            print("Point on Y-axis")
        [var x, var y] when y == x:
            print("Point on line y = x")
        [var x, var y] when y == -x:
            print("Point on line y = -x")
        [var x, var y]:
            print("Point (%s, %s)" % [x, y])

- If there is no matching pattern for the current branch, the pattern guard
  is **not** evaluated and the patterns of the next branch are checked.
- If a matching pattern is found, the pattern guard is evaluated.

  - If it's true, then the body of the branch is executed and ``match`` ends.
  - If it's false, then the patterns of the next branch are checked.

Classes
-------

By default, all script files are unnamed classes. In this case, you can only
reference them using the file's path, using either a relative or an absolute
path. For example, if you name a script file ``character.gd``::

   # Inherit from 'character.gd'.

   extends "res://path/to/character.gd"

   # Load character.gd and create a new node instance from it.

   var Character = load("res://path/to/character.gd")
   var character_node = Character.new()

.. _doc_gdscript_basics_class_name:

Registering named classes
~~~~~~~~~~~~~~~~~~~~~~~~~

You can give your class a name to register it as a new type in Godot's
editor. For that, you use the ``class_name`` keyword. You can optionally use
the ``@icon`` annotation with a path to an image, to use it as an icon. Your
class will then appear with its new icon in the editor::

   # item.gd

   @icon("res://interface/icons/item.png")
   class_name Item
   extends Node

.. image:: img/class_name_editor_register_example.png

.. tip::

    SVG images that are used as custom node icons should have the
    **Editor > Scale With Editor Scale** and **Editor > Convert Icons With Editor Theme**
    :ref:`import options <doc_importing_images_editor_import_options>` enabled. This allows
    icons to follow the editor's scale and theming settings if the icons are designed with
    the same color palette as Godot's own icons.

Here's a class file example:

::

    # Saved as a file named 'character.gd'.

    class_name Character


    var health = 5


    func print_health():
        print(health)


    func print_this_script_three_times():
        print(get_script())
        print(ResourceLoader.load("res://character.gd"))
        print(Character)

If you want to use ``extends`` too, you can keep both on the same line::

    class_name MyNode extends Node

.. note::

    Godot initializes non-static variables every time you create an instance,
    and this includes arrays and dictionaries. This is in the spirit of thread safety,
    since scripts can be initialized in separate threads without the user knowing.

.. warning::

    The Godot editor will hide these custom classes with names that begin with the prefix
    "Editor" in the 'Create New Node' or 'Create New Scene' dialog windows. The classes
    are available for instantiation at runtime via their class names, but are
    automatically hidden by the editor windows along with the built-in editor nodes used
    by the Godot editor.

Inheritance
~~~~~~~~~~~

A class (stored as a file) can inherit from:

- A global class.
- Another class file.
- An inner class inside another class file.

Multiple inheritance is not allowed.

Inheritance uses the ``extends`` keyword::

    # Inherit/extend a globally available class.
    extends SomeClass

    # Inherit/extend a named class file.
    extends "somefile.gd"

    # Inherit/extend an inner class in another file.
    extends "somefile.gd".SomeInnerClass

.. note::

    If inheritance is not explicitly defined, the class will default to inheriting
    :ref:`class_RefCounted`.

To check if a given instance inherits from a given class,
the ``is`` keyword can be used::

    # Cache the enemy class.
    const Enemy = preload("enemy.gd")

    # [...]

    # Use 'is' to check inheritance.
    if entity is Enemy:
        entity.apply_damage()

To call a function in a *super class* (i.e. one ``extend``-ed in your current
class), use the ``super`` keyword::

    super(args)

This is especially useful because functions in extending classes replace
functions with the same name in their super classes. If you still want to
call them, you can use ``super``::

    func some_func(x):
        super(x) # Calls the same function on the super class.

If you need to call a different function from the super class, you can specify
the function name with the attribute operator::

    func overriding():
        return 0 # This overrides the method in the base class.

    func dont_override():
        return super.overriding() # This calls the method as defined in the base class.

.. warning::

    One of the common misconceptions is trying to override *non-virtual* engine methods
    such as ``get_class()``, ``queue_free()``, etc. This is not supported for technical reasons.

    In Godot 3, you can *shadow* engine methods in GDScript, and it will work if you call this method in GDScript.
    However, the engine will **not** execute your code if the method is called inside the engine on some event.

    In Godot 4, even shadowing may not always work, as GDScript optimizes native method calls.
    Therefore, we added the ``NATIVE_METHOD_OVERRIDE`` warning, which is treated as an error by default.
    We strongly advise against disabling or ignoring the warning.

    Note that this does not apply to virtual methods such as ``_ready()``, ``_process()`` and others
    (marked with the ``virtual`` qualifier in the documentation and the names start with an underscore).
    These methods are specifically for customizing engine behavior and can be overridden in GDScript.
    Signals and notifications can also be useful for these purposes.

Class constructor
~~~~~~~~~~~~~~~~~

The class constructor, called on class instantiation, is named ``_init``. If you
want to call the base class constructor, you can also use the ``super`` syntax.
Note that every class has an implicit constructor that is always called
(defining the default values of class variables). ``super`` is used to call the
explicit constructor::

    func _init(arg):
       super("some_default", arg) # Call the custom base constructor.

This is better explained through examples. Consider this scenario::

    # state.gd (inherited class).
    var entity = null
    var message = null


    func _init(e=null):
        entity = e


    func enter(m):
        message = m


    # idle.gd (inheriting class).
    extends "state.gd"


    func _init(e=null, m=null):
        super(e)
        # Do something with 'e'.
        message = m

There are a few things to keep in mind here:

1. If the inherited class (``state.gd``) defines a ``_init`` constructor that takes
   arguments (``e`` in this case), then the inheriting class (``idle.gd``) *must*
   define ``_init`` as well and pass appropriate parameters to ``_init`` from ``state.gd``.
2. ``idle.gd`` can have a different number of arguments than the base class ``state.gd``.
3. In the example above, ``e`` passed to the ``state.gd`` constructor is the same ``e`` passed
   in to ``idle.gd``.
4. If ``idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to pass some value
   to the ``state.gd`` base class, even if it does nothing. This brings us to the fact that you
   can pass expressions to the base constructor as well, not just variables, e.g.::

    # idle.gd

    func _init():
        super(5)

Static constructor
~~~~~~~~~~~~~~~~~~

A static constructor is a static function ``_static_init`` that is called automatically
when the class is loaded, after the static variables have been initialized::

    static var my_static_var = 1

    static func _static_init():
        my_static_var = 2

A static constructor cannot take arguments and must not return any value.

.. _doc_gdscript_basics_inner_classes:

Inner classes
~~~~~~~~~~~~~

A class file can contain inner classes. Inner classes are defined using the
``class`` keyword. They are instanced using the ``ClassName.new()``
function.

::

    # Inside a class file.

    # An inner class in this class file.
    class SomeInnerClass:
        var a = 5


        func print_value_of_a():
            print(a)


    # This is the constructor of the class file's main class.
    func _init():
        var c = SomeInnerClass.new()
        c.print_value_of_a()

.. _doc_gdscript_classes_as_resources:

Classes as resources
~~~~~~~~~~~~~~~~~~~~

Classes stored as files are treated as :ref:`GDScripts <class_GDScript>`. They
must be loaded from disk to access them in other classes. This is done using
either the ``load`` or ``preload`` functions (see below). Instancing of a loaded
class resource is done by calling the ``new`` function on the class object::

    # Load the class resource when calling load().
    var MyClass = load("myclass.gd")

    # Preload the class only once at compile time.
    const MyClass = preload("myclass.gd")


    func _init():
        var a = MyClass.new()
        a.some_function()

Exports
-------

.. note::

    Documentation about exports has been moved to :ref:`doc_gdscript_exports`.


.. _doc_gdscript_basics_setters_getters:

Properties (setters and getters)
--------------------------------

Sometimes, you want a class' member variable to do more than just hold data and actually perform
some validation or computation whenever its value changes. It may also be desired to
encapsulate its access in some way.

For this, GDScript provides a special syntax to define properties using the ``set`` and ``get``
keywords after a variable declaration. Then you can define a code block that will be executed
when the variable is accessed or assigned.

Example::

    var milliseconds: int = 0
    var seconds: int:
        get:
            return milliseconds / 1000
        set(value):
            milliseconds = value * 1000

.. note::

    Unlike ``setget`` in previous Godot versions, ``set`` and ``get`` methods are **always** called (except as noted below),
    even when accessed inside the same class (with or without prefixing with ``self.``). This makes the behavior
    consistent. If you need direct access to the value, use another variable for direct access and make the property
    code use that name.

Alternative syntax
~~~~~~~~~~~~~~~~~~

Also there is another notation to use existing class functions if you want to split the code from the variable declaration
or you need to reuse the code across multiple properties (but you can't distinguish which property the setter/getter is being called for)::

    var my_prop:
        get = get_my_prop, set = set_my_prop

This can also be done in the same line::

    var my_prop: get = get_my_prop, set = set_my_prop

The setter and getter must use the same notation, mixing styles for the same variable is not allowed.

.. note::

    You cannot specify type hints for *inline* setters and getters. This is done on purpose to reduce the boilerplate.
    If the variable is typed, then the setter's argument is automatically of the same type, and the getter's return value must match it.
    Separated setter/getter functions can have type hints, and the type must match the variable's type or be a wider type.

When setter/getter is not called
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a variable is initialized, the value of the initializer will be written directly to the variable.
Including if the ``@onready`` annotation is applied to the variable.

Using the variable's name to set it inside its own setter or to get it inside its own getter will directly access the underlying member,
so it won't generate infinite recursion and saves you from explicitly declaring another variable::

    signal changed(new_value)
    var warns_when_changed = "some value":
        get:
            return warns_when_changed
        set(value):
            changed.emit(value)
            warns_when_changed = value

This also applies to the alternative syntax::

    var my_prop: set = set_my_prop

    func set_my_prop(value):
        my_prop = value # No infinite recursion.

.. warning::

    The exception does **not** propagate to other functions called in the setter/getter.
    For example, the following code **will** cause an infinite recursion::

        var my_prop:
            set(value):
                set_my_prop(value)

        func set_my_prop(value):
            my_prop = value # Infinite recursion, since `set_my_prop()` is not the setter.

.. _doc_gdscript_tool_mode:

Tool mode
---------

By default, scripts don't run inside the editor and only the exported
properties can be changed. In some cases, it is desired that they do run
inside the editor (as long as they don't execute game code or manually
avoid doing so). For this, the ``@tool`` annotation exists and must be
placed at the top of the file::

    @tool
    extends Button

    func _ready():
        print("Hello")


See :ref:`doc_running_code_in_the_editor` for more information.

.. warning:: Be cautious when freeing nodes with ``queue_free()`` or ``free()``
             in a tool script (especially the script's owner itself). As tool
             scripts run their code in the editor, misusing them may lead to
             crashing the editor.

.. _doc_gdscript_basics_memory_management:

Memory management
-----------------

Godot implements reference counting to free certain instances that are no longer
used, instead of a garbage collector, or requiring purely manual management.
Any instance of the :ref:`class_RefCounted` class (or any class that inherits
it, such as :ref:`class_Resource`) will be freed automatically when no longer
in use. For an instance of any class that is not a :ref:`class_RefCounted`
(such as :ref:`class_Node` or the base :ref:`class_Object` type), it will
remain in memory until it is deleted with ``free()`` (or ``queue_free()``
for Nodes).

.. note::

    If a :ref:`class_Node` is deleted via ``free()`` or ``queue_free()``,
    all of its children will also recursively be deleted.

To avoid reference cycles that can't be freed, a :ref:`class_WeakRef`
function is provided for creating weak references, which allow access
to the object without preventing a :ref:`class_RefCounted` from freeing.
Here is an example:


::

    extends Node

    var my_file_ref

    func _ready():
        var f = FileAccess.open("user://example_file.json", FileAccess.READ)
        my_file_ref = weakref(f)
        # the FileAccess class inherits RefCounted, so it will be freed when not in use

        # the WeakRef will not prevent f from being freed when other_node is finished
        other_node.use_file(f)

    func _this_is_called_later():
        var my_file = my_file_ref.get_ref()
        if my_file:
            my_file.close()

Alternatively, when not using references, the
``is_instance_valid(instance)`` can be used to check if an object has been
freed.

.. _doc_gdscript_signals:

Signals
-------

Signals are a tool to emit messages from an object that other objects can react
to. To create custom signals for a class, use the ``signal`` keyword.

::

   extends Node


   # A signal named health_depleted.
   signal health_depleted

.. note::

   Signals are a `Callback
   <https://en.wikipedia.org/wiki/Callback_(computer_programming)>`_
   mechanism. They also fill the role of Observers, a common programming
   pattern. For more information, read the `Observer tutorial
   <https://gameprogrammingpatterns.com/observer.html>`_ in the
   Game Programming Patterns ebook.

You can connect these signals to methods the same way you connect built-in
signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody3D`.

In the example below, we connect the ``health_depleted`` signal from a
``Character`` node to a ``Game`` node. When the ``Character`` node emits the
signal, the game node's ``_on_character_health_depleted`` is called::

    # game.gd

    func _ready():
        var character_node = get_node('Character')
        character_node.health_depleted.connect(_on_character_health_depleted)


    func _on_character_health_depleted():
        get_tree().reload_current_scene()

You can emit as many arguments as you want along with a signal.

Here is an example where this is useful. Let's say we want a life bar on screen
to react to health changes with an animation, but we want to keep the user
interface separate from the player in our scene tree.

In our ``character.gd`` script, we define a ``health_changed`` signal and emit
it with :ref:`Signal.emit() <class_Signal_method_emit>`, and from
a ``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` using
the :ref:`Signal.connect() <class_Signal_method_connect>` method::

    # character.gd

    ...
    signal health_changed


    func take_damage(amount):
        var old_health = health
        health -= amount

        # We emit the health_changed signal every time the
        # character takes damage.
        health_changed.emit(old_health, health)
    ...

::

    # lifebar.gd

    # Here, we define a function to use as a callback when the
    # character's health_changed signal is emitted.

    ...
    func _on_Character_health_changed(old_value, new_value):
        if old_value > new_value:
            progress_bar.modulate = Color.RED
        else:
            progress_bar.modulate = Color.GREEN

        # Imagine that `animate` is a user-defined function that animates the
        # bar filling up or emptying itself.
        progress_bar.animate(old_value, new_value)
    ...

In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, then
connect the character, that emits the signal, to the receiver, the ``Lifebar``
node in this case.

::

    # game.gd

    func _ready():
        var character_node = get_node('Character')
        var lifebar_node = get_node('UserInterface/Lifebar')

        character_node.health_changed.connect(lifebar_node._on_Character_health_changed)

This allows the ``Lifebar`` to react to health changes without coupling it to
the ``Character`` node.

You can write optional argument names in parentheses after the signal's
definition::

    # Defining a signal that forwards two arguments.
    signal health_changed(old_value, new_value)

These arguments show up in the editor's node dock, and Godot can use them to
generate callback functions for you. However, you can still emit any number of
arguments when you emit signals; it's up to you to emit the correct values.

.. image:: img/gdscript_basics_signals_node_tab_1.png

GDScript can bind an array of values to connections between a signal
and a method. When the signal is emitted, the callback method receives
the bound values. These bound arguments are unique to each connection,
and the values will stay the same.

You can use this array of values to add extra constant information to the
connection if the emitted signal itself doesn't give you access to all the data
that you need.

Building on the example above, let's say we want to display a log of the damage
taken by each character on the screen, like ``Player1 took 22 damage.``. The
``health_changed`` signal doesn't give us the name of the character that took
damage. So when we connect the signal to the in-game console, we can add the
character's name in the binds array argument::

    # game.gd

    func _ready():
        var character_node = get_node('Character')
        var battle_log_node = get_node('UserInterface/BattleLog')

        character_node.health_changed.connect(battle_log_node._on_Character_health_changed.bind(character_node.name))

Our ``BattleLog`` node receives each element in the binds array as an extra argument::

    # battle_log.gd

    func _on_Character_health_changed(old_value, new_value, character_name):
        if not new_value <= old_value:
            return

        var damage = old_value - new_value
        label.text += character_name + " took " + str(damage) + " damage."


Awaiting signals or coroutines
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``await`` keyword can be used to create `coroutines <https://en.wikipedia.org/wiki/Coroutine>`_
which wait until a signal is emitted before continuing execution. Using the ``await`` keyword with a signal or a
call to a function that is also a coroutine will immediately return the control to the caller. When the signal is
emitted (or the called coroutine finishes), it will resume execution from the point on where it stopped.

For example, to stop execution until the user presses a button, you can do something like this::

    func wait_confirmation():
        print("Prompting user")
        await $Button.button_up # Waits for the button_up signal from Button node.
        print("User confirmed")
        return true

In this case, the ``wait_confirmation`` becomes a coroutine, which means that the caller also needs to await it::

    func request_confirmation():
        print("Will ask the user")
        var confirmed = await wait_confirmation()
        if confirmed:
            print("User confirmed")
        else:
            print("User cancelled")

Note that requesting a coroutine's return value without ``await`` will trigger an error::

    func wrong():
        var confirmed = wait_confirmation() # Will give an error.

However, if you don't depend on the result, you can just call it asynchronously, which won't stop execution and won't
make the current function a coroutine::

    func okay():
        wait_confirmation()
        print("This will be printed immediately, before the user press the button.")

If you use await with an expression that isn't a signal nor a coroutine, the value will be returned immediately and the
function won't give the control back to the caller::

    func no_wait():
        var x = await get_five()
        print("This doesn't make this function a coroutine.")

    func get_five():
        return 5

This also means that returning a signal from a function that isn't a coroutine will make the caller await that signal::

    func get_signal():
        return $Button.button_up

    func wait_button():
        await get_signal()
        print("Button was pressed")

.. note:: Unlike ``yield`` in previous Godot versions, you cannot obtain the function state object.
          This is done to ensure type safety.
          With this type safety in place, a function cannot say that it returns an ``int`` while it actually returns a function state object
          during runtime.

Assert keyword
--------------

The ``assert`` keyword can be used to check conditions in debug builds. These
assertions are ignored in non-debug builds. This means that the expression
passed as argument won't be evaluated in a project exported in release mode.
Due to this, assertions must **not** contain expressions that have
side effects. Otherwise, the behavior of the script would vary
depending on whether the project is run in a debug build.

::

    # Check that 'i' is 0. If 'i' is not 0, an assertion error will occur.
    assert(i == 0)

When running a project from the editor, the project will be paused if an
assertion error occurs.

You can optionally pass a custom error message to be shown if the assertion
fails::

    assert(enemy_power < 256, "Enemy is too powerful!")
